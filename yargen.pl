#!/usr/bin/env perl

use warnings;
use strict;
use feature qw/say/;

use Mojo::UserAgent;
use Data::Printer;
use Storable qw/store retrieve/;
use Getopt::Long;

my $arg_string = join(" ", $0, @ARGV);
my $module = 'File::Spec';
my $cve = 'CVE-2015-6607';
my $help = 0;

GetOptions("m|module=s" => \$module,
           "c|cve=s"    => \$cve,
           "help"       => \$help)
or die("Error in command line arguments\n");

if ($help) {
	say "HELP!!!\n"
}

die "Please, provide perl module name.\n"
	unless $module;

die "'$module' is not a valid perl module name.\n"
	unless $module =~ /^\w++((?:::)\w++)?$/;

die "Please, provide cve(or other id) argument.\n"
	unless $cve;

if ($cve =~ /^CVE/i) {
   unless ($cve =~ /^CVE-\d{4}-\d{4}$/i) {
      die "'$cve' is not a valid ave id.\n"
   }
}

my $mmodule = 'Perl' . $module =~ s/:++//gr  . 'Module';
my $ccve = uc($cve =~ tr/-/_/r);

my $dump = $module . '.dump';
my @modules;

if (-f $dump) {
   @modules = @{retrieve($dump)};
}

unless (@modules) {
   my $ua = Mojo::UserAgent->new();
   my $r = $ua->get('https://metacpan.org/pod/' . $module);
   if ($r->success && $r->res->code() == 200) {
      my $cl = $r->res->dom
                      ->find('div.release.status-latest.maturity-released select option')
                      ->map(attr => 'value')
                      ->compact()
                      ->map(sub{s!^/module!https://api.metacpan.org/source!r})
                      ->sort()
                      ->uniq();
      @modules = $cl->map(sub {
            my $r = $ua->get($_);
            if ($r->success && $r->res->code() == 200) {
               $r->res->body
            } else {
               warn "Can't get module $_\n";
               undef
            }
         }
      )->compact()->each();
      store \@modules, $dump;
   } else {
      warn "Module not found on metacpan\n";
   }
}

sub trim {
   $_[0] =~ s/(^\s++)|(\s++$)//gr
}

sub to_regex {
   my $v = $_[0];
   $v =~ s!\h+!\\s*!g;
   $v =~ s!([\$\^()\[\]])!\\$1!g;
   $v =~ s!['"]!(\\'|\\")!g;
   $v =~ s!our\\s\K\*!+!g;
   $v;
}


my %versions;
my $ident = 0;
foreach(@modules) {
   #if (/^.*?v(?:e(?:r(?:s(?:i(?:o(?:n)?)?)?)?)?)?\h*=\h*(?:['"])([^'"]++)(?:['"])\h*;.*$/pim) {
   if (/^.*?v(?:e(?:r(?:s(?:i(?:o(?:n)?)?)?)?)?)?\h*=\h*.*?(\d++(?:[\.\:\-\_]\w++)*).*?;/pim) {
      my $v   = trim(${^MATCH});
      my $ver = 'v_' . $1 =~ tr/./_/r;
      $ident = length($ver)
         if $ident < length($ver);
      unless (exists $versions{$ver}) {
         $versions{$ver} = $v;
      } else {
         die "Different signatures of same version $ver: '$v' and '$versions{$ver}'\n"
            unless $versions{$ver} eq $v;
      }
   } else {
      die "Failed to find version string in module:\n'$_'\n";
   }
}
my $str = '';
foreach(reverse sort keys %versions) {
   my $i = ' ' x ($ident - length($_) + 1);
   my $r = to_regex($versions{$_});
   $str .= "\t\t$_" . $i . "= '$r'\n";
}


say "#This rule was generated by: $arg_string\n";
my $private_rule_tmpl =
"private rule $mmodule
{
\tmeta:
\t\tcustom_description = \"Private rule for identifying Perl $module Module\"
\tstrings:
\t\t\$package = /package\\s+$module;/
\tcondition:
\t\t\$package
}";
say $private_rule_tmpl;

say '';

my $yara_rule_tmpl =
"rule $ccve
{
\tmeta:
\tstrings:
$str
\tcondition:
\t\t$mmodule and any of (\$v*)
}";
say $yara_rule_tmpl;

